// nip19.ts
import { bytesToHex, concatBytes, hexToBytes } from "@noble/hashes/utils";
import { bech32 } from "@scure/base";

// utils.ts
var utf8Decoder = new TextDecoder("utf-8");
var utf8Encoder = new TextEncoder();
function normalizeURL(url) {
  if (url.indexOf("://") === -1)
    url = "wss://" + url;
  let p = new URL(url);
  p.pathname = p.pathname.replace(/\/+/g, "/");
  if (p.pathname.endsWith("/"))
    p.pathname = p.pathname.slice(0, -1);
  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
    p.port = "";
  p.searchParams.sort();
  p.hash = "";
  return p.toString();
}

// nip19.ts
var Bech32MaxSize = 5e3;
function decode(nip19) {
  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
          author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : void 0,
          kind: tlv[3]?.[0] ? parseInt(bytesToHex(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for naddr");
      if (!tlv[2]?.[0])
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!tlv[3]?.[0])
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(tlv[0][0]),
          pubkey: bytesToHex(tlv[2][0]),
          kind: parseInt(bytesToHex(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nrelay": {
      let tlv = parseTLV(data);
      if (!tlv[0]?.[0])
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder.decode(tlv[0][0])
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}

// nip11.ts
var _fetch;
try {
  _fetch = fetch;
} catch {
}
async function fetchRelayInformation(url) {
  return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}

// nip29.ts
function subscribeRelayGroups(pool, url, params) {
  let normalized = normalizeURL(url);
  let sub;
  let groups = [];
  fetchRelayInformation(normalized).then(async (info) => {
    let rl = await pool.ensureRelay(normalized);
    params.onconnect?.();
    sub = rl.prepareSubscription(
      [
        {
          kinds: [39e3],
          limit: 50,
          authors: [info.pubkey]
        }
      ],
      {
        onevent(event) {
          groups.push(parseGroup(event, normalized));
        },
        oneose() {
          params.ongroups(groups);
          sub.onevent = (event) => {
            groups.push(parseGroup(event, normalized));
            params.ongroups(groups);
          };
        }
      }
    );
    sub.fire();
  }).catch(params.onerror);
  return () => sub.close();
}
async function loadGroup(pool, gr) {
  let normalized = normalizeURL(gr.host);
  let info = await fetchRelayInformation(normalized);
  let event = await pool.get([normalized], {
    kinds: [39e3],
    authors: [info.pubkey],
    "#d": [gr.id]
  });
  if (!event)
    throw new Error(`group '${gr.id}' not found on ${gr.host}`);
  return parseGroup(event, normalized);
}
async function loadGroupFromCode(pool, code) {
  let gr = parseGroupCode(code);
  if (!gr)
    throw new Error(`code "${code}" does not identify a group`);
  return loadGroup(pool, gr);
}
function parseGroupCode(code) {
  if (code.startsWith("naddr1")) {
    try {
      let { data } = decode(code);
      let { relays, identifier } = data;
      if (!relays || relays.length === 0)
        return null;
      let host = relays[0];
      if (host.startsWith("wss://")) {
        host = host.slice(6);
      }
      return { host, id: identifier };
    } catch (err) {
      return null;
    }
  } else if (code.split("'").length === 2) {
    let spl = code.split("'");
    return { host: spl[0], id: spl[1] };
  }
  return null;
}
function encodeGroupReference(gr) {
  if (gr.host.startsWith("https://"))
    gr.host = gr.host.slice(8);
  if (gr.host.startsWith("wss://"))
    gr.host = gr.host.slice(6);
  return `${gr.host}'${gr.id}`;
}
function parseGroup(event, relay) {
  const group = { relay, pubkey: event.pubkey };
  for (let i = 0; i < event.tags.length; i++) {
    const tag = event.tags[i];
    switch (tag[0]) {
      case "d":
        group.id = tag[1] || "";
        break;
      case "name":
        group.name = tag[1] || "";
        break;
      case "about":
        group.about = tag[1] || "";
        break;
      case "picture":
        group.picture = tag[1] || "";
        break;
      case "open":
        group.open = true;
        break;
      case "public":
        group.public = true;
        break;
    }
  }
  return group;
}
function parseMembers(event) {
  const members = [];
  for (let i = 0; i < event.tags.length; i++) {
    const tag = event.tags[i];
    if (tag.length < 2)
      continue;
    if (tag[0] !== "p")
      continue;
    if (!tag[1].match(/^[0-9a-f]{64}$/))
      continue;
    const member = { pubkey: tag[1], permissions: [] };
    if (tag.length > 2)
      member.label = tag[2];
    if (tag.length > 3)
      member.permissions = tag.slice(3);
    members.push(member);
  }
  return members;
}
export {
  encodeGroupReference,
  loadGroup,
  loadGroupFromCode,
  parseGroup,
  parseGroupCode,
  parseMembers,
  subscribeRelayGroups
};

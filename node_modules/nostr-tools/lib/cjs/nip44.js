"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// nip44.ts
var nip44_exports = {};
__export(nip44_exports, {
  default: () => nip44_default,
  v2: () => v2
});
module.exports = __toCommonJS(nip44_exports);
var import_chacha = require("@noble/ciphers/chacha");
var import_utils = require("@noble/ciphers/utils");
var import_secp256k1 = require("@noble/curves/secp256k1");
var import_hkdf = require("@noble/hashes/hkdf");
var import_hmac = require("@noble/hashes/hmac");
var import_sha256 = require("@noble/hashes/sha256");
var import_utils2 = require("@noble/hashes/utils");
var import_base = require("@scure/base");
var decoder = new TextDecoder();
var _u = class {
  static utf8Decode(bytes) {
    return decoder.decode(bytes);
  }
  static getConversationKey(privkeyA, pubkeyB) {
    const sharedX = import_secp256k1.secp256k1.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
    return (0, import_hkdf.extract)(import_sha256.sha256, sharedX, "nip44-v2");
  }
  static getMessageKeys(conversationKey, nonce) {
    const keys = (0, import_hkdf.expand)(import_sha256.sha256, conversationKey, nonce, 76);
    return {
      chacha_key: keys.subarray(0, 32),
      chacha_nonce: keys.subarray(32, 44),
      hmac_key: keys.subarray(44, 76)
    };
  }
  static calcPaddedLen(len) {
    if (!Number.isSafeInteger(len) || len < 1)
      throw new Error("expected positive integer");
    if (len <= 32)
      return 32;
    const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
    const chunk = nextPower <= 256 ? 32 : nextPower / 8;
    return chunk * (Math.floor((len - 1) / chunk) + 1);
  }
  static writeU16BE(num) {
    if (!Number.isSafeInteger(num) || num < _u.minPlaintextSize || num > _u.maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const arr = new Uint8Array(2);
    new DataView(arr.buffer).setUint16(0, num, false);
    return arr;
  }
  static pad(plaintext) {
    const unpadded = _u.utf8Encode(plaintext);
    const unpaddedLen = unpadded.length;
    const prefix = _u.writeU16BE(unpaddedLen);
    const suffix = new Uint8Array(_u.calcPaddedLen(unpaddedLen) - unpaddedLen);
    return (0, import_utils2.concatBytes)(prefix, unpadded, suffix);
  }
  static unpad(padded) {
    const unpaddedLen = new DataView(padded.buffer).getUint16(0);
    const unpadded = padded.subarray(2, 2 + unpaddedLen);
    if (unpaddedLen < _u.minPlaintextSize || unpaddedLen > _u.maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + _u.calcPaddedLen(unpaddedLen))
      throw new Error("invalid padding");
    return _u.utf8Decode(unpadded);
  }
  static hmacAad(key, message, aad) {
    if (aad.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const combined = (0, import_utils2.concatBytes)(aad, message);
    return (0, import_hmac.hmac)(import_sha256.sha256, key, combined);
  }
  static decodePayload(payload) {
    if (typeof payload !== "string")
      throw new Error("payload must be a valid string");
    const plen = payload.length;
    if (plen < 132 || plen > 87472)
      throw new Error("invalid payload length: " + plen);
    if (payload[0] === "#")
      throw new Error("unknown encryption version");
    let data;
    try {
      data = import_base.base64.decode(payload);
    } catch (error) {
      throw new Error("invalid base64: " + error.message);
    }
    const dlen = data.length;
    if (dlen < 99 || dlen > 65603)
      throw new Error("invalid data length: " + dlen);
    const vers = data[0];
    if (vers !== 2)
      throw new Error("unknown encryption version " + vers);
    return {
      nonce: data.subarray(1, 33),
      ciphertext: data.subarray(33, -32),
      mac: data.subarray(-32)
    };
  }
};
var u = _u;
__publicField(u, "minPlaintextSize", 1);
__publicField(u, "maxPlaintextSize", 65535);
__publicField(u, "utf8Encode", import_utils2.utf8ToBytes);
var v2 = class {
  static encrypt(plaintext, conversationKey, nonce = (0, import_utils2.randomBytes)(32)) {
    const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce);
    const padded = u.pad(plaintext);
    const ciphertext = (0, import_chacha.chacha20)(chacha_key, chacha_nonce, padded);
    const mac = u.hmacAad(hmac_key, ciphertext, nonce);
    return import_base.base64.encode((0, import_utils2.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));
  }
  static decrypt(payload, conversationKey) {
    const { nonce, ciphertext, mac } = u.decodePayload(payload);
    const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce);
    const calculatedMac = u.hmacAad(hmac_key, ciphertext, nonce);
    if (!(0, import_utils.equalBytes)(calculatedMac, mac))
      throw new Error("invalid MAC");
    const padded = (0, import_chacha.chacha20)(chacha_key, chacha_nonce, ciphertext);
    return u.unpad(padded);
  }
};
__publicField(v2, "utils", u);
var nip44_default = { v2 };
